---
title: 【原理】指针和引用
tags:
  - 指针
  - 引用
  - C++
categories: 原理
comments: true
img: https://blog.xtcgch.ink/img/动漫/pic-07.jpg
urlname: pointer&ref
abbrlink: 59937
date: 2018-11-23 22:49:27
---

**摘要**：本文主要讲C++中指针相关的知识点。

<!--more-->

---

## 1、脑图

![指针图谱](./指针.png)


---


## 2、概述



---


## 3、特点

（1）指针


（2）引用

---


## 4、指针类别

### 4.1 空指针
- 在C++11之前，使用0或者NULL来赋予空指针
- 在C++11之后，使用nullptr来赋予空指针

### 4.2 智能指针

1、简介：
（1）头文件<memory>
（2）在C++11标准后才正式可用

**2、shared_ptr<>()**
（1）特点
- 引用计数，复制时只是复制指针，当计数为0时，调用元素的析构函数
（2）初始化：使用make_shared<>()进行构造智能指针
（3）复制：
（4）注意事项：

**3、unique_ptr<>()**
（1）特点
- unique_ptr只能有一个使用权，不同的unique_ptr之间只能进行move转移使用权
（2）初始化：使用make_unique<>()进行构造只能指针
（3）复制：
（4）注意事项：

**4、weak_ptr<>()**
（1）特点
- unique_ptr只能有一个使用权，不同的unique_ptr之间只能进行move转移使用权
（2）初始化：使用make_unique<>()进行构造只能指针
（3）复制：
（4）注意事项：

### 4.3 数组指针
1、简介
本质是一个指针，指向一个数组

2、声明和定义
int (* p)[10];
* p、* p++、p[1]


3、删除
delete[]

4、例子
```
int a[3][4];
int (* p)[4]; //该语句是定义一个数组指针，指向含4个元素的一维数组。
 p=a;        //将该二维数组的首地址赋给p，也就是a[0]或&a[0][0]
 p++;       //该语句执行过后，也就是p=p+1;p跨过行a[0][]指向了行a[1][]
 ```

### 4.4 指针数组
1、简介
本质是一个数组，存放的都是指针

2、声明和定义
int * (p[])

3、删除
delete[] p

4、例子
int * p[3];
int a[3][4];
p++; //该语句表示p数组指向下一个数组元素。注：此数组每一个元素都是一个指针
for(i=0;i<3;i++)
p[i]=a[i]
这里int * p[3] 表示一个一维数组内存放着三个指针变量，分别是p[0]、p[1]、p[2]
所以要分别赋值。
比如要表示数组中i行j列一个元素：
* (p[i]+j)、* (* (p+i)+j)、(* (p+i))[j]、p[i][j]


---


## 5、指针操作

### 5.1 移动
当指针为数组指针时，有2种移动指针的方法，一种是使用加法：p+=n，一种是使用下标：p[n]。

### 5.2 初始化和赋值
（1）可以使用zeromemory()和memset()函数来进行指针初始化。
（2）可以使用memcpy()函数来进行数组指针的赋值。

### 5.3 内存申请和删除 
（1）使用new进行申请内存，通过判断p是否为空指针来知晓是否申请内存成功
（2）new申请的内存：
- 指针指向单个对象时，使用delete进行删除
- 指针指向数组时，使用delete[]进行删除

---


## 6、指针和引用的区别

- 定义和性质区别：

（1）指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元;

而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已

（2）可以有const指针，但是没有const引用

（3）指针可以有多级，但是引用只能是一级（int ** p；合法 而 int &&a是不合法的）

（4）指针的值可以为空，但是引用的值不能为NULL，并且引用在定义的时候必须初始化

(5)指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变了

(6)"sizeof引用"得到的是所指向的变量(对象)的大小，而"sizeof指针"得到的是指针本身的大小

(7)指针和引用的自增(++)运算意义不一样

- 作为函数参数进行传递时的区别

指针传递的是一个副本，引用传递的是本身

---

## 7、注意事项

（1）空指针
- 使用时需要先判断是否为空指针，方法有if(nullptr==p)或者assert(nullptr==p)
- 如果指针指向了一块堆内的内存，如果在未删除内存时把指针设为空指针，则造成了内存泄漏

（2）野指针
- 造成原因：删除指针指向的内存后，未给指针赋空值，所以原指针指向了一个不确定的内存
- 解决方案：删除指针指向的内存后，使用nullptr赋值为空指针