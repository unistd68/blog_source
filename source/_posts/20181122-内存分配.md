---
title: 【原理】内存分配、管理和算法
tags:
  - 内存管理
  - 内存分配
  - 操作系统
urlname: memory-allocate
categories: 原理
comments: true
img: https://blog.xtcgch.ink/img/动漫/pic-04.jpg
abbrlink: 57807
date: 2018-11-23 16:00:00
---

**摘要**：内存分配是指在程序执行的过程中分配或者回收存储空间的分配内存的方法。
<!--more-->

## 栈和堆

（1）栈上的内存主要是由操作系统分配，不会发生内存泄漏，堆上的内存一般由程序员分配释放，若不释放，程序结束时可能由OS回收

（2）栈上的分配内存的大小是有限制，超出上限会分配失败，而堆上的内存分配则是没有大小限制

（3）堆区是公有的，栈区是线程独有的

（4）什么是堆：堆是大家**共有**的空间，分全局堆和局部堆。
全局堆就是所有没有分配的空间，局部堆就是用户分配的空间。
堆在操作系统对进程 初始化的时候分配，运行过程中也可以向系统要额外的堆，但是记得用完了要还给操作系统，要不然就是内存泄漏。

什么是栈：栈是线程**独有**的，保存其运行状态和局部自动变量的。
栈在线程开始的时候初始化，每个线程的栈互相独立。
每个函数都有自己的栈，栈被用来在函数之间传递参数。
操作系统在切换线程的时候会自动的切换栈，就是切换SS/ESP寄存器。
栈空间不需要在高级语言里面显式的分配和释放。

注意：堆区与数据结构中的堆是两回事，分配方式倒是类似于链表。

错误示例：

    void Function(void) 
    { 
        char *p = (char *)malloc(100 * sizeof(char)); 
    }

就这个例子，千万不要认为函数返回，函数所在的栈被销毁指针也跟着销毁，申请的内存也就一样跟着销毁了！这绝对是错误的！因为申请的内存在**堆**上，而函数所在的**栈**被销毁跟堆完全没有啥关系。

---

## 动态内存分配和静态内存分配


### 动态内存分配

动态内存分配(Dynamic Memory Allocation)就是指在程序执行的过程中动态地分配或者回收存储空间的分配内存的方法。动态内存分配不象数组等静态内存分配方法那样需要预先分配存储空间，而是由系统根据程序的需要即时分配，且分配的大小就是程序要求的大小。

### 静态内存分配

静态的内存使用的是栈空间内存，不用程序员自己来分配。因为静态变量占用的存储空间对于编译器而言是可预计的，静态内存只需要编程的时候直接声明就可以了。

---

## malloc 和 new

**1、联系**

（1）都是动态分配内存

（2）在释放内存后，原指针要进行相关的处理

**2、区别**

（1）申请的内存所在位置

**new**操作符从自由存储区（free store）上为对象动态分配内存空间（自由存储区可以是**堆**，可以是**静态存储区**）

**malloc**函数从**堆**上动态分配内存

（2）返回类型安全性

new是符合**类型安全**性的操作符：
**new**操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换

malloc是**非类型安全**性的操作符：
malloc内存分配成功则是返回`void *` ，需要通过强制类型转换将`void *` 指针转换成我们需要的类型

（3）内存分配失败时的返回值

**new**内存分配失败时，会抛出**bac_alloc**异常，它不会返回NULL

**malloc**分配内存失败时返回**NULL**，需要去判断是否分配成功

**malloc**检查分配内存是否成功：

```
	int *a  = (int *)malloc ( sizeof (int ));
	if(NULL == a)
	{
	    ...
	}
	else 
	{
	    ...
	}
```

**new**检查分配内存是否成功：

```
	try
	{
	    int *a = new int();
	}
	catch (bad_alloc)
	{
	    ...
	}
```


（4）是否需要指定内存大小

new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而malloc则需要显式地指出所需内存的尺寸

```
 1、int* parr = new int [100] ; 则分配大小为 sizeof(int) * 100 
 2、int* parr = （int *）malloc （100 * sizeof（int））
```

（5）是否调用构造函数/析构函数

使用**new**操作符来分配对象内存时会经历三个步骤：

第一步：调用operator new 函数（对于数组是operator new[]）分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象。 
第二步：编译器运行相应的构造函数以构造对象，并为其传入初值。 
第三步：对象构造完成后，返回一个指向该对象的指针。

使用**delete**操作符来释放对象内存时会经历两个步骤：

第一步：调用对象的析构函数。
 第二步：编译器调用operator delete(或operator delete[])函数释放内存空间。 
 总之来说，new/delete会调用对象的构造函数/析构函数以完成对象的构造/析构。而malloc则不会。

（6）对数组的处理

**new**对数组的支持体现在它会分别调用构造函数函数初始化每一个数组元素，释放对象时为每个对象调用析构函数。

注意delete[]要与new[]配套使用，不然会找出数组对象部分释放的现象，造成内存泄漏。

至于malloc，它并知道你在这块内存上要放的数组还是啥别的东西，反正它就给你一块原始的内存，在给你个内存的地址就完事。

所以如果要动态分配一个数组的内存，还需要我们手动自定数组的大小

（7）new与malloc是否可以相互调用

operator new /operator delete的实现可以基于malloc，而malloc的实现不可以去调用new


（8）是否可以被重载

opeartor new /operator delete可以被重载。标准库是定义了operator new函数和operator delete函数的8个重载版本

 而malloc/free并不允许重载

（9）能够直观地重新分配内存

使用**malloc**分配的内存后，如果在使用过程中发现内存不足，可以使用**realloc**函数进行内存重新分配实现内存的扩充。

**realloc**先判断当前的指针所指内存是否有足够的连续空间，如果有，**原地扩大**可分配的内存地址，并且返回原来的地址指针；如果空间不够，先按照新指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来的内存区域。

**new**没有这样直观的配套设施来扩充内存。

（10）客户处理内存分配不足

在operator new抛出异常以反映一个未获得满足的需求之前，它会先调用一个用户指定的错误处理函数，这就是new-handler

对于malloc，客户并不能够去编程决定内存不足以分配时要干什么事，只能看着malloc返回NULL


注意：
（1）重复分配内存会使得内存泄漏
（2）重复释放内存会发生错误

---

## 连续内存分配方式

1）固定分区分配

将内存划分成若干个固定大小的块。将程序装入块中即可。内存划分成各个块之后，块大小不再改变。当然，划分块的方式有：所有的块大小相等；划分的块大小不相等。

这种方式，在实际的内存分配之前，就已经知道了所有的内存块大小了。

 

2）动态分区分配

需要一个空闲表 或者 空闲链 来记录目前系统中空间的内存区域。在内存分配时，需要查找空间表或空闲链找到一块内存分配给当前进程。

 

动态分区分配算法：

a)首次适应法

b)循环首次适应法

c)最佳适应法

d)最坏适应法

e)快速适应法

 

3）可重定位分区分配

说白了，就是增加了内存移动的功能。由于若干次内存分配与回收之后，各个空闲的内存块不连续了。通过“重定位”，将已经分配的内存“紧凑”在一块（就类似于JVM垃圾回收中的复制算法）从而空出一大块空闲的内存出来。

”紧凑“是需要开销的，比如需要重新计算 地址，这也为什么JVM垃圾回收会导致STW的原因。

而离散分配方式--不管是分页还是分段，都是直接将程序放到各个离散的页中。从而就不存在“紧凑”一说了。

 

连续内存分配方式涉及两种操作：内存分配操作 和 内存回收操作

 

## 离散内存分配方式

内存资源是有限的，程序要运行，必须得加载到内存。如果内存已经满了，而现在又有新的程序要运行，怎么办？---SWAP

把当前不用的程序(数据)先换出内存，从而就有空间 加载当前需要运行的程序的一部分数据进入内存，这样大大提高了内存的利用率。

由于牵涉到换入与换出，前面的连续内存分配方式就有点不适用了。因为，最明显的一个问题：对于连续内存分配方式，究竟换出哪部分数据呢？

而这种只装入部分"数据"就可以使程序运行的机制，就是虚拟存储器的本质。

---

## 参考文章

- [文章一](http://www.cnblogs.com/huhuuu/archive/2013/11/19/3432371.html)
- [文章二](https://www.cnblogs.com/hapjin/p/5689049.html)